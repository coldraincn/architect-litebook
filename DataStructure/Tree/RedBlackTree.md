# 红黑树
*参考《算法》第四版3.3
## 2-3查找树
为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键
### 定义
>一颗2-3查找树或为一颗空树，或由以下结点组成：
> * 2-结点，含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
> * 3-结点，含有两个键和三条链接，左链接指向2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点
### 图例
![2-3树](../images/23tree.png)
*一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的*
### 查询
略
### 向2-结点中插入新键
如果查找未命中结束于一个2-结点，只要将要插入的键保存在该2-结点即可
### 向一颗只含有一个3-结点的树中插入新键
为了将新建插入，可以临时讲新键插入到该3-节点中，使之称为一个4-结点。该4-结点可以很容易的转换为一颗有3个2-结点组成的2-3树，根结点含有中键，左结点含有最小的键，右结点含有最大的键。插入前书的高度为0，插入后高度为1，表明了2-3树的生长过程。
![向只有一个3-结点插入](../images/i3.png)
### 向一个父结点为2-结点的3-结点中插入新键
依旧是将该3-结点转化为4-结点，然后将该4-结点的中键移动到父结点，父结点的中链接指向4-结点的最小值，右链接指向最大值。
![父结点为2-结点](../images/i23.png)
### 向一个父结点为3-结点的3-结点中插入新键
递归的将3-结点转化为4-结点，然后分解，直到遇到一个2-结点并替换为不需要分解的3-结点或者达到3-结点的根。
![33结点插入](../images/i331.png)
如果从插入的结点到根结点都是3-结点，跟节点就会变成一个临时的4-结点。此时我们可以按照向一颗只有一个3-结点的树中插入新键的方法处理这个问题，使树的高度增加1，但仍然保持了树的完美平衡，因为变换的是根结点
![分解根结点](../images/i332.png)
### 局部变换
![分解4-结点的总汇](../images/4sum.png)
如上图所示，将一个4-结点分解为一颗2-3树可能有6种情况，这个4-结点可能是根结点，可能是一个2-结点的左子结点或者右子结点，也可能是一个3-结点的左子结点，中子结点或者右子结点。2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必须、修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。需要特别指出的是，不光是在树的底部，树中的任何地方只要符合相应的模式，变换都可以进行。每个变换都会将4-结点中的一个键送入他的父节点中，并重构相应的链接而不必涉及树的其他部分。
### 全局性质
局部变换不会影响树的局部有序性和平衡性：任意空链接到根结点的路径长度都是相等的。
### 总结
在一颗大小为n的2-3树中，查找和插入操作访问的结点必然不超过lgn个。因为需要处理的情况太多，需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型。开销可能会比标准的二叉搜索树更慢，由此我们通过一点代价就能用一种统一的形式完成所有变换，这就是红黑树。
## 红黑树
### 定义
>红黑树的一种定义是含有红黑链接并满足下列条件的二叉查找树
>* 红链接均为左链接
>* 没有任何一个结点同时和两条红链接相连
>* 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同
### 与2-3树关系
红黑树背后的基本思想是用标准的二叉查找树和一些额外的信息来表示2-3树。将树中的链接分为两种类型：红链接将两个2-结点链接起来构成一个3-节点，黑链接则是2-3树中的普通链接。确切的说，将3-结点表示为由一条左斜的红色链接相连的2-节点。如下图所示。如果将一颗红黑树中的红链接画平，那么所有的空链接到根结点的距离都是相同的。如果将红链接相连的结点合并，得到的就是2-3树。相反，如果将一颗2-3树中的3-结点画作由红色左链接相连的两个2-节点，那么不会存在能够和两条红链接相连的节点。
![红色节点](../images/rednode.png)
### 结点的颜色表示
将一个结点的颜色定义为指向它的链接的颜色（从父结点指向它），如果指向它的链接是红色，那么该变量为true，黑色则为false。约定空链接为黑色。
```java
private static final boolean RED=true;
private static final boolean BLACK=false;

private class Node{
    Key key;//键
    Value val;//相关联的值
    Node left,right;//左右子树
    int N;//这颗子树中结点总数
    boolean color;//父结点指向它的链接的颜色
    Node(Key key,Value val,int N,boolean color){
        this.key=key;
        this.val=val;
        this.N=N;
        this.color=color
    }
}
// 测试结点x和它父结点之间的链接的颜色
private boolean isRed(Node x){
    if(x==null){
        return false;
    }
    return x.color==RED;
}
```
### 旋转
实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心的旋转并修复。旋转操作会改变红链接的指向。假设有一条红色的右链接需要被转化为左链接，这个操作称为左旋转。大体思路是将两个键中的较小者作为根节点变为较大者作为根结点。实现降一个红色左链接转换为一个红色右链接的一个右旋转的代码完全相同，只需要调换left和right即可。
```java
Node rotateLeft(Node h){
    Node x = h.left;
    h.right = x.left;
    x.left = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    h.N=1+size(h.left)+size(h.right);
    return x;
}
Node rotateRight(Node h){
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color=h.color;
    h.color=RED;
    x.N=h.N;
    h.N=1+size(h.right)+size(h.left);
    return x;
}
```
*左旋转*
![坐旋转1](../images/rotateleft1.png)
*左旋转结果*
![左旋转2](../images/rotateleft2.png)
*右旋转*
![右旋转1](../images/rotateright1.png)
*右旋转结果*
![右旋转2](../images/rotateright2.png)

### 旋转后重置父节点的链接
无论左旋转还是右旋转，旋转操作都会返回一条链接，总会用旋转的两个方法的返回值重置父结点中相应的链接。
### 向2-结点（根结点）中插入新键
如果插入的结点键值小于老健，只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。如果新键大于老键，新增的红色结点会产生一条红色的右链接，需要root=rotateLeft(root),将其旋转为红色做链接并修正根结点的链接
![2-结点插入新键](../images/2-node.png)
### 向树底的2-结点插入新键
用和二叉查找树相同的方法向红黑树中插入新键，会在树的底部新增一个结点，但总是用红色链接将新结点和它的父链接相连。如果父链接是个2-结点，当指向新链接是父结点的左链接，那么父节点就直接成了一个3-结点；当指向新链接是父结点的右链接，进行一次左旋转。
![树底部的2-结点插入](../images/2-node2.png)
### 向一颗双键数（3-结点，根结点）中插入新键
可以分为三种情况，每种情况都会产生一个同时连接到两条红链接的结点。
1. 新键大于原树中的两个键
此时新键被链接到3-结点的右链接，树是平衡的，根结点为中间大小的键，两条红链接分别和较小和较大的结点相连。如果将两条链接的颜色都由红变黑，那么我们得到了一颗由三个结点组成，高为2的平衡树，正好对应一颗2-3树。*其他两种情况也会转化为这种情况*
![3-结点中插入第一种情况](../images/3-node1.png)
2. 新键小于原树中的两个键
此时，新键会被链接到最左边的空链接，这样产生了两条连续的红链接，只需要将上层的红链接右旋转即可得到第一种情况
![3-结点中插入第二种情况](../images/3-node2.png)
3. 新键介于原树中的两个键之间
又会产生两条连续的红链接，一条红色左链接接一条红色右链接，只需要将下层的红链接左旋转即可得到第二种情况，然后继续得到第一种情况
![3-结点中插入第三种情况](../images/3-node3.png)
### 颜色转换
使用一个颜色转换方法来转换一个结点的两个红色子结点的颜色，除了将子节点的颜色由红变黑之外，同时还要将父结点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响*整棵树的黑色平衡性*
 ```java
 void flipColors(Node h){
     h.color = RED;
     h.left.color = BLACK;
     h.right.color = BLACK;
 }
 ```
 ### 根结点总是黑色
 3-结点插入新键的三种情况中，颜色转换会使根结点变为红色。严格的说，红色根结点说明结点是一个3-结点的一部分，但实际情况并不是这样。一次每次插入后都会将根结点设为黑色，每当根结点由红色变黑色时，树的黑链接高度就会加1；
 ### 向树底部的3-结点插入新键
 前面讨论的三种情况都会出现，根据不同情况进行旋转以及颜色转换。颜色转换会使到中结点的链接变红，相当于把它送入到了父结点。意味着父结点中继续插入一个新键。
 ![向底部的3-结点插入新键](../images/3-nodefloor.png)
 ### 将红链接在树中向上传递
 2-3树中的插入算法需要我们分解3-结点，将中间键插入父结点，如此这般直到遇到一个2-s
 * 如果右子结点是红色而左子结点是黑色的，进行左旋转
 * 如果左子结点是红色的且它（左子结点）的左子结点也是红色的，进行右旋转
 * 如果左右子结点均为红色，进行颜色转换
 ![红链接向上传递](../images/rbtup.png)
 ### 插入算法实现
 ```java
 public void put(Key key,Value){
     root = put(root,key,val);
     root.color = BLACK;
 }
 private Node put(Node h,Key key,Value val){
     if(h==null){
         return new Node(key,val,1,RED);
     }
     int cmp = key.compareTo(h.key);
     if(cmp<0){
         h.left = put(h.left,key,val);
     }else if(cmp>0){
         h.right = put(h.right,key,val);
     }else{
         h.val = val;
     }
     if(isRed(h.right) && !isRed(h.left)){
         h = rotateLeft(h);
     }
     if(isRed(h.left) && isRed(h.left.left)){
         h = rotateRight(h);
     }
     if(isRed(h.left) && isRed(h.right)){
         flipColors(h);
     }
     h.N = size(h.left) + size(h.right) + 1;
     return h;
 }
 ```
 ### 删除
 #### 删除最小
 树底部的3-结点删除很简单，但从2-结点中删除一个键会留下一个空结点，会破坏树的完美平衡性，为了保证不会删除2-结点，沿着左链接向下进行变换，确保当前结点不是2-结点。在沿着做链接向下的过程中，保证一下情况之一成立：
 1. 如果当前结点的左子结点不是2-结点，完成
 2. 当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移动到左子结点中
 3. 如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点，父结点的最小键和左子结点最近的兄弟结点合并成4-结点使父结点由3-结点变为2-结点，或者由4-结点变为3-结点
 ![删除最小键变换](../images/rbtdelemin.png)
 #### 删除
 删除操作在查找路径上进行和删除最小键相同的变换，可以保证在查找过程中任意当前结点均不是2-结点。
